---
title: Disco
description: Official documentation for Disco, a modern and simple library for scoped dependency injection in Flutter.
---

Disco is a library introducing a new concept of providers that operate differently from those already present in the Flutter ecosystem. It was developed to overcome the challenges and limitations in the context of dependency injection.

## Simple usage example

The package supports many features, like providers that accept arguments. But to keep things simple, here is a basic example to get you started:

1. Create a provider top level.

    ```dart {1}
    final modelProvider = Provider((context) => Model());
    ```

    **Note:** the state is never stored globally, directly in the Provider instance; see this provider solely as a type-safe identifier.

2. Scope/provide the provider.

    ```dart {7, 8, 9, 10}
    class ProvidingWidget extends StatelessWidget {
      
      const ProvidingWidget({super.key});

      @override
      Widget build(BuildContext context) {
        return ProviderScope(
          providers: [modelProvider],
          child: MyWidget(),
        );
      }
    }
    ```

    **Note:** the actual state for the provider is created and stored inside the `ProviderScope` instance where the provider is referenced.
    This way, when the ProviderScope gets disposed, the state gets disposed — making it ideal for managing **local state**.

3. Inject the provider directly inside a new stateless widget or a stateful widget's state.

    ```dart {7}
    class InjectingWidget extends StatelessWidget {

      const InjectingWidget({super.key});

      @override
      Widget build(BuildContext context) {
        final model = modelProvider.of(context);
        // return .. (use model here)
      }
    }
    ```

    **Note:** the `ProviderScope` defined in step 2 needs to be an ancestor of this `InjectingWidget` widget.

### Widget tree structure

To make things clear, here is the widget tree structure from the example above, shown in the most detailed form:

* `modelProvider` — a globally defined provider

* `main` — the entry point of every Dart application, also global

  * ... — setup widget(s)

    * `ProvidingWidget`

      * `ProviderScope` — *`modelProvider` is provided here*

        * `MyWidget`

          * ... — widget(s)

            * `InjectingWidget` — *`modelProvider` is injected here*

              * ... — widget(s)

## What is unique about this library

The **key difference between Disco and other established solutions** is that Disco **does not rely solely on types** for providing and injecting dependencies.

This part dives a bit deeper into technical details. Let's consider the popular [Provider](https://pub.dev/packages/provider) package; it requires you to declare providers directly in the widget tree using something like `Provider(create: (_) => Model())`, and later retrieve them with `context.read<Model>()`. This approach works but is limited — it injects the *first instance of the given type* it finds, which can be restrictive.

Disco, by contrast, uses **globally defined provider instances as identifiers**. This allows for much greater flexibility, including defining **multiple providers of the same type**. For example:

1. Multiple providers of the same type can be defined globally.

    ```dart
    final modelProvider = Provider((context) => Model());
    final secondModelProvider = Provider((context) => Model());
    ```

2. Providers of the same type can be provided in the same scope:

    ```dart
    class ProvidingWidget extends StatelessWidget {
      
      const ProvidingWidget({super.key});

      @override
      Widget build(BuildContext context) {
        return ProviderScope(
          providers: [modelProvider, secondModelProvider],
          child: MyWidget(),
        );
      }
    }
    ```

3. Provers of the same type can also be injected together:

    ```dart
    class InjectingWidget extends StatelessWidget {

      const InjectingWidget({super.key});

      @override
      Widget build(BuildContext context) {
        final model = modelProvider.of(context);
        final secondModel = secondModelProvider.of(context);
        // return .. (use model and secondModel here)
      }
    }
    ```

Of course, the providers don’t need to be defined in the same scope to be used together, and they don’t need to be injected in the same widget either. This setup is just meant to demonstrate what’s possible.

This kind of setup is not possible with Provider or other scoped DI libraries in the ecosystem — unless you resort to defining separate wrapper types like `MyModelWrapper1` and `MyModelWrapper2`, which adds complexity and makes the code harder to reason about.

<details>
<summary><strong>If the difference is still not clear</strong>, click <strong>here</strong> to expand</summary>

The table below highlights the core conceptual difference: traditional DI solutions inject based on **type**, whereas Disco injects based on **provider instances**. If Disco followed the same method-style API, it might look like `context.read(modelProvider)` — which is more intuitive in direct comparisons.

| Injection Task        | Typical Scoped DI (e.g., Provider) | Disco (Conceptual Syntax)           | Disco (Actual Syntax)            |
|-----------------------|------------------------------------|-------------------------------------|----------------------------------|
| Inject `Model`        | `context.read<Model>()`            | `context.read(modelProvider)`       | `modelProvider.of(context)`      |
| Inject second `Model` | Not possible                       | `context.read(secondModelProvider)` | `secondModelProvider.of(context)` |

Note that Disco intentionally flips the order — the provider comes first — to better align with Flutter conventions (`.of(context)`) and improve clarity. This makes it immediately obvious **what** you are injecting. This syntax is also slightly better for autocomplete and inlay hints display a more concise type.

</details>

## Trade-offs

### Pros

The pros of Disco are:

- The providers are scoped.
  - The widget tree is fully leveraged.
    - This keeps the architecture simple.
- No global state is possible.
  - Circular dependencies are impossible.
- Multiple providers of the same type are possible.
  - There is no need to create wrapper types or rely on IDs such as strings.
- The API is very simple and feels natural to Flutter.
  - Providers are equipped with `of(context)` and `maybeOf(context)` methods.
  - All you need is `BuildContext`. There is no additional class needed to inject the providers.
- The removal of a provider has an impact on its providing and each of its injections.
  - Each of them is immediately characterized by a static error.
- The values held by the providers are immutable.
  - While immutable, some instances allow for inner mutation.
    - This is great: observables and signals can be passed down.
- No reactivity is included.
  - This library focuses on DI, so that state management solutions can focus on the reactivity.
  - To include reactivity, provide a built-in or third-party observable/signal to the provider (e.g. `Signal`, `ChangeNotifier`, `Cubit`, ...).

### Cons

The cons of this library are:

- Providers might need to be lifted up or down in the widget tree, as requirements change.
- Modals spawn new widget trees, causing disconnection with the providers in the main tree.
  - A special widget must be used to restore access to the providers in the main widget tree.
- It is not fully compile-time safe.
  - The injection of a provider that cannot be found in any scope results in a runtime error.

In Disco's defense regarding the last point:

- Total compile-time safety is not possible with an approach leveraging scoped DI, which is a pattern ubiquitously used in Flutter and third-party libraries (think about how many times you have already read `MediaQuery.of(context)`, `GoRouter.of(context)`, ...).
- Disco providers also have a `maybeOf(context)` method, which can help if the presence of a provider cannot be guaranteed.
- The throwable includes precise information in its stack trace to deduce the missing provider: filepath, line and column.

### Keep in mind

As the <a href="/authors">authors of Disco</a>, we believe this to be the most effective strategy for DI in Flutter. However, every solution has trade-offs. You can limit the impact of these trade-offs by running tests, doing code reviews, and following other crucial practices.
