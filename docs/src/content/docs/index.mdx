---
title: Disco
description: Official documentation for Disco, a modern and simple library for scoped dependency injection in Flutter.
---

Disco is a library introducing a new concept of providers that operate differently from those already present in the Flutter ecosystem. It was developed to overcome the challenges and limitations in the context of dependency injection.


## Table of content

- [Simple usage example](#simple-usage-example)
- [What is unique about this library](#what-is-unique-about-this-library)
- [Trade-offs](#trade-offs)

## Simple usage example

The package supports many features, like providers that accept arguments. But to keep things simple, here is a basic example to get you started:

1. Define a provider at the top level.

    ```dart {1}
    final modelProvider = Provider((context) => Model());
    ```

    **Note:** the state is never stored globally, directly in the Provider instance; see this provider solely as a type-safe identifier.

2. Insert a `ProviderScope` at the desired point in the widget tree to define the scope of the provider and make it accessible to the corresponding subtree.

    ```dart {1, 2, 3, 4}
    ProviderScope(
      providers: [modelProvider],
      child: MyWidget(),
    )
    ```

    **Note:** the actual state for the provider is created and stored inside the `ProviderScope` instance where the provider is referenced.
    This way, when the ProviderScope gets disposed, the state gets disposed — making it ideal for managing **local state**.

3. Inject the provider directly inside a new stateless widget or a stateful widget's state.

    ```dart {7}
    class InjectingWidget extends StatelessWidget {

      const InjectingWidget({super.key});

      @override
      Widget build(BuildContext context) {
        final model = modelProvider.of(context);
        // return .. (use model here)
      }
    }
    ```

    **Note:** the `ProviderScope` defined in step 2 needs to be an ancestor of this `InjectingWidget` widget.

<details>
<summary><strong>If the widget tree structure is still not clear</strong>, click <strong>here</strong> to expand</summary>

### Expanded: Widget tree structure

To make things clear, here is the widget tree structure from the example above, shown in the most detailed form:

* `modelProvider` — a globally defined provider

* `main` — the entry point of every Dart application, also global

  * ... — setup widget(s)

    * `ProviderScope` — *`modelProvider` is provided here*

      * `MyWidget` — the child defined in the second code snippet if you notice carefully

        * ... — widget(s)

          * `InjectingWidget` — *`modelProvider` is injected here*

            * ... — widget(s)

</details>

## What is unique about this library

The **key difference** between Disco and other established scoped solutions is that **Disco does not rely solely on types** for providing and injecting dependencies; **by contrast**, it uses **globally defined provider instances as identifiers**. This allows for much greater flexibility, especially defining **multiple providers of the same type**.

<details>
<summary><strong>For precise steps on how to use multiple providers of the same type</strong>, click <strong>here</strong> to expand</summary>

### Expanded: Multiple providers of the same type

1. Define multiple providers of the same generic type at the top level.

    ```dart {1, 2}
    final modelProvider = Provider((context) => Model());
    final secondModelProvider = Provider((context) => Model());
    ```

2. Insert a `ProviderScope` at the desired point in the widget tree to define the scope of the providers and make them accessible to the corresponding subtree.

    ```dart {1, 2, 3, 4}
    ProviderScope(
      providers: [modelProvider, secondModelProvider],
      child: MyWidget(),
    )
    ```

3. Inject the provider directly inside a new stateless widget or a stateful widget's state.

    ```dart {7, 8}
    class InjectingWidget extends StatelessWidget {

      const InjectingWidget({super.key});

      @override
      Widget build(BuildContext context) {
        final model = modelProvider.of(context);
        final secondModel = secondModelProvider.of(context);
        // return .. (use model and secondModel here)
      }
    }
    ```

Of course, the providers don’t need to be defined in the same scope to be used together, and they don’t need to be injected in the same widget either. This setup is just meant to demonstrate what’s possible.

</details>

### Typical Scoped DI vs Disco: Side-by-side comparison

Let's consider the — by far — most popular scoped DI package: [Provider](https://pub.dev/packages/provider). It requires you to declare providers directly in the widget tree using something like `Provider(create: (_) => Model())`, and later retrieve them with `context.read<Model>()`. This approach works but is limited — it injects the *first instance of the given type* it finds, which can be restrictive.

The table below highlights the core conceptual difference: traditional DI solutions inject based on **type**, whereas Disco injects based on **provider instances**. If Disco followed the same method-style API as the Provider package, it might look like `context.read(modelProvider)`. This conceptual syntax is not the actual one, but is a bit more intuitive in direct comparisons.

<table>
  <tr>
    <th><span style="font-size: 0.65em;">Solution/Injection</span></th>
    <th><span style="font-size: 0.65em;">Inject <code>Model</code></span></th>
    <th><span style="font-size: 0.65em;">Inject second <code>Model</code></span></th>
  </tr>
  <tr>
    <td><span style="font-size: 0.65em;">Typical Scoped DI</span></td>
    <td><span style="font-size: 0.65em;"><code>context.read&lt;Model&gt;()</code></span></td>
    <td><span style="font-size: 0.65em;">Not possible</span></td>
  </tr>
  <tr>
    <td><span style="font-size: 0.65em;">Disco (Conceptual Syntax)</span></td>
    <td><span style="font-size: 0.65em;"><code>context.read(modelProvider)</code></span></td>
    <td><span style="font-size: 0.65em;"><code>context.read(secondModelProvider)</code></span></td>
  </tr>
  <tr>
    <td><span style="font-size: 0.65em;">Disco (Actual Syntax)</span></td>
    <td><span style="font-size: 0.65em;"><code>modelProvider.of(context)</code></span></td>
    <td><span style="font-size: 0.65em;"><code>secondModelProvider.of(context)</code></span></td>
  </tr>
</table>

Note that Disco intentionally flips the order — the provider comes first — to better align with Flutter conventions (the `.of(context)` part).

Injecting different providers of the same type is not possible with [Provider](https://pub.dev/packages/provider) or other scoped DI libraries in the ecosystem — unless you resort to defining separate wrapper types like `MyModelWrapper1` and `MyModelWrapper2`; such process, however, adds complexity and can make the code harder to reason about.

### Comparison with global solutions

While many existing solutions support multiple providers of the same type (without wrapper types, string identifiers or similar), they typically rely on globally-scoped-endorsed approaches (such as [Riverpod](https://pub.dev/packages/riverpod)). In contrast, **Disco** is — to our knowledge — the **first and only solution** to support multiple providers of the same type **purely through local scoping that aligns with the widget tree structure**  without introducing wrapper types, string identifiers, or similar.

## Trade-offs

### Pros

The pros of Disco are:

- The providers are scoped.
  - The widget tree is fully leveraged.
    - This keeps the architecture simple.
- No global state is possible.
  - Circular dependencies are impossible.
- Multiple providers of the same type are possible.
  - There is no need to create wrapper types or rely on IDs such as strings.
- The API is very simple and feels natural to Flutter.
  - Providers are equipped with `of(context)` and `maybeOf(context)` methods.
  - All you need is `BuildContext`. There is no additional class needed to inject the providers.
- The removal of a provider has an impact on its providing and each of its injections.
  - Each of them is immediately characterized by a static error.
- The values held by the providers are immutable.
  - While immutable, some instances allow for inner mutation.
    - This is great: observables and signals can be passed down.
- No reactivity is included.
  - This library focuses on DI, so that state management solutions can focus on the reactivity.
  - To include reactivity, provide a built-in or third-party observable/signal to the provider (e.g. `Signal`, `ChangeNotifier`, `Cubit`, ...).

### Cons

The cons of this library are:

- Providers might need to be lifted up or down in the widget tree, as requirements change.
- Modals spawn new widget trees, causing disconnection with the providers in the main tree.
  - A special widget must be used to restore access to the providers in the main widget tree.
- It is not fully compile-time safe.
  - The injection of a provider that cannot be found in any scope results in a runtime error.

In Disco's defense regarding the last point:

- Total compile-time safety is not possible with an approach leveraging scoped DI, which is a pattern ubiquitously used in Flutter and third-party libraries (think about how many times you have already read `MediaQuery.of(context)`, `GoRouter.of(context)`, ...).
- Disco providers also have a `maybeOf(context)` method, which can help if the presence of a provider cannot be guaranteed.
- The throwable includes precise information in its stack trace to deduce the missing provider: filepath, line and column.

### Keep in mind

As the <a href="/authors">authors of Disco</a>, we believe this to be the most effective strategy for DI in Flutter. However, every solution has trade-offs. You can limit the impact of these trade-offs by running tests, doing code reviews, and following other crucial practices.
