---
title: Disco
description: Official documentation for Disco, a modern and simple library for scoped dependency injection in Flutter.
---

Disco is a library introducing a new concept of providers that operate differently from those already present in the Flutter ecosystem. It was developed to overcome the challenges and limitations in the context of dependency injection.


## Table of content

- [Simple usage example](#simple-usage-example)
- [What makes this library unique](#what-makes-this-library-unique)
- [Trade-offs](#trade-offs)

## Simple usage example

The package supports many features, like providers that accept arguments. But to keep things simple, here is a basic example to get you started:

1. Define a provider at the top level.

    ```dart {1}
    final modelProvider = Provider((context) => Model());
    ```

    **Note:** the state is never stored globally, directly in the Provider instance; see this provider solely as a type-safe identifier.

2. Insert a `ProviderScope` at the desired point in the widget tree to define the scope of the provider and make it accessible to the corresponding subtree.

    ```dart {1, 2, 3, 4}
    ProviderScope(
      providers: [modelProvider],
      child: MyWidget(),
    )
    ```

    **Note:** the actual state for the provider is created and stored inside the `ProviderScope` instance where the provider is referenced.
    This way, when the ProviderScope gets disposed, the state gets disposed — making it ideal for managing **local state**.

3. Inject the provider directly inside a new stateless widget or a stateful widget's state.

    ```dart {7}
    class InjectingWidget extends StatelessWidget {

      const InjectingWidget({super.key});

      @override
      Widget build(BuildContext context) {
        final model = modelProvider.of(context);
        // return .. (use model here)
      }
    }
    ```

    **Note:** the `ProviderScope` defined in step 2 needs to be an ancestor of this `InjectingWidget` widget.

<details>
<summary><strong>If the widget tree structure is still not clear</strong>, click <strong>here</strong> to expand</summary>

### Expanded: Widget tree structure

To make things clear, here is the widget tree structure from the example above, shown in the most detailed form:

* `modelProvider` — a globally defined provider

* `main` — the entry point of every Dart application, also global

  * ... — setup widget(s)

    * `ProviderScope` — *`modelProvider` is provided here*

      * `MyWidget` — the child defined in the second code snippet if you notice carefully

        * ... — widget(s)

          * `InjectingWidget` — *`modelProvider` is injected here*

            * ... — widget(s)

</details>

## What makes this library unique

Disco takes a fundamentally different approach to dependency injection in Flutter. It is — **to our knowledge** — the **first and only solution** that supports **multiple providers of the same type** (without wrapper types or string identifiers) while staying **purely local**, aligned with the **natural structure of the Flutter widget tree**.

Let’s walk through what this really means and how it compares with Provider and Riverpod — the two most popular DI libraries featuring providers — both of which have had a huge influence on the design and philosophy behind this library.

### Glimpse into Provider

The [`Provider`](https://pub.dev/packages/provider) package (and libraries built on top of it like [Bloc (BlocProvider component)](https://pub.dev/packages/flutter_bloc#blocprovider])) let you scope dependencies using the widget tree. However, **they rely entirely on types** to resolve injections.

This means you can only have **one provider per type** in a branch of the tree.

```dart
void main() {
  runApp(
    Provider<Model>(
      create: (_) => Model(),
      child: MaterialApp(
        home: MyWidget(),
      ),
    ),
  );
}

/// In the subtree of MyWidget.
class MyScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Reads the first Model above this widget in the tree
    final model = context.read<Model>();
    // return ...
  }
}
```

If you want two different `Model` instances, you can't just write:

```dart
/// In the subtree of MyWidget.
class MyScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Reads the first Model above this widget in the tree
    final model = context.read<Model>();
    // This one also reads the first Model it finds instead of reading the second one in the tree...
    final secondModel = context.read<Model>();
    // return ...
  }
}
```

You are forced to create wrapper types like `PrimaryModel`, `SecondaryModel`, etc., to distinguish between different providers. This clutters your codebase and increases boilerplate.

### Glimpse into Riverpod

Libraries like [`Riverpod`](https://pub.dev/packages/riverpod) solve the above limitation by allowing **multiple providers of the same type**, using globally defined provider *instances* as identifiers:

```dart
final modelProvider = Provider((ref) => Model());
final secondModelProvider = Provider((ref) => Model());
```

The `ref` is a special object that allow to access providers.

Note that **the state for these providers is not local** — it's managed from a single, top-level `ProviderScope`:

```dart
void main() {
  runApp(
    // The state for all providers is handled here, not in the providers themselves.
    ProviderScope(
      child: MyApp(),
    ),
  );
}
```

Without this `ProviderScope`, it is not possible to access any provider.

In order to access a provider, you must use specialized widgets (`ConsumerWidget`, `ConsumerStatefulWidget`) instead of Flutter's native ones.

#### Parameterized Providers and Lifecycle Management in Riverpod

Riverpod offers powerful modifiers like `family` and `autoDispose` to enhance provider flexibility and lifecycle:

* **`family`** enables **parameterized providers** allowing multiple instances of the same provider with different parameters:

  ```dart
  final userProvider = Provider.family<User, int>((ref, userId) {
    return fetchUser(userId);
  });
  ```

  This provides the illusion of scoped instances but with important caveats:

  * All instances remain **globally stored** within the single top-level `ProviderScope`.
  * Lifecycle is **not tightly bound to the widget tree**, complicating disposal and resource management.
  * Breaks the Flutter principle of *“let the tree define scope.”*

* **`autoDispose`** automatically cleans up providers when no longer used by any widget:

  ```dart
  final userProvider = Provider.autoDispose<User>((ref) {
    return fetchUser();
  });
  ```

  However:

  * It still operates inside the global `ProviderScope`, so it’s **not true local scoping**.
  * Providers are **not removed while any widget is listening**, potentially extending their lifecycle beyond expectations.
  * May cause unexpected disposal and recreation during fast navigation or widget rebuilds.

Together, `family` and `autoDispose` enhance flexibility and resource handling in Riverpod but don’t offer true local, widget-tree-based scoping and lifecycle guarantees.

### Disco: The best of both worlds

Disco **combines** the **type flexibility of Riverpod** with the **explicit scoping of Provider** — while reducing the downsides of both to a minimum.

#### Providers as identifiers

You define providers as top-level identifiers. They can be of the same generic type, as in the example below.

```dart
final modelProvider = Provider((context) => Model());
final secondModelProvider = Provider((context) => Model());
```

Disco uses the **provider instance**, not the return type, to locate dependencies — allowing multiple providers of the same type *without confusion*.

#### Scoped where you need it

You insert a `ProviderScope` **where** you want the providers to be active — no global registry required.

```dart
ProviderScope(
  providers: [modelProvider, secondModelProvider],
  child: MyWidget(),
)
```

This is **true scoping**, fully aligned with the widget tree.

#### Clean and type-safe injection

No special widget base class is needed. Just call the `of` (or `maybeOf` if optional) method of the provider:

```dart
class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final model = modelProvider.of(context);
    final secondModel = secondModelProvider.of(context);

    return Text(model.toString() + " " + secondModel.toString());
  }
}
```

You can inject providers in **any** `StatelessWidget` or `StatefulWidget`.

## Trade-offs

### Pros

The pros of Disco are:

- The providers are scoped.
  - The widget tree is fully leveraged.
    - This keeps the architecture simple.
- No global state is possible.
  - Circular dependencies are impossible.
- Multiple providers of the same type are possible.
  - There is no need to create wrapper types or rely on IDs such as strings.
- The API is very simple and feels natural to Flutter.
  - Providers are equipped with `of(context)` and `maybeOf(context)` methods.
  - All you need is `BuildContext`. There is no additional class needed to inject the providers.
- The removal of a provider has an impact on its providing and each of its injections.
  - Each of them is immediately characterized by a static error.
- The values held by the providers are immutable.
  - While immutable, some instances allow for inner mutation.
    - This is great: observables and signals can be passed down.
- No reactivity is included.
  - This library focuses on DI, so that state management solutions can focus on the reactivity.
  - To include reactivity, provide a built-in or third-party observable/signal to the provider (e.g. `Signal`, `ChangeNotifier`, `Cubit`, ...).

### Cons

The cons of this library are:

- Providers might need to be lifted up or down in the widget tree, as requirements change.
- Modals spawn new widget trees, causing disconnection with the providers in the main tree.
  - A special widget must be used to restore access to the providers in the main widget tree.
- It is not fully compile-time safe.
  - The injection of a provider that cannot be found in any scope results in a runtime error.

In Disco's defense regarding the last point:

- Total compile-time safety is not possible with an approach leveraging scoped DI, which is a pattern ubiquitously used in Flutter and third-party libraries (think about how many times you have already read `MediaQuery.of(context)`, `GoRouter.of(context)`, ...).
- Disco providers also have a `maybeOf(context)` method, which can help if the presence of a provider cannot be guaranteed.
- The throwable includes precise information in its stack trace to deduce the missing provider: filepath, line and column.

### Keep in mind

As the <a href="/authors">authors of Disco</a>, we believe this to be the most effective strategy for DI in Flutter. However, every solution has trade-offs. You can limit the impact of these trade-offs by running tests, doing code reviews, and following other crucial practices.
