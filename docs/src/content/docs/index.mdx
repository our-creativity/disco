---
title: Disco
description: Official documentation for Disco, a modern and simple library for scoped dependency injection in Flutter.
---

Disco is a library introducing a new concept of providers that operate differently from those already present in the Flutter ecosystem. It was developed to overcome the challenges and limitations in the context of dependency injection.

## Simple usage example

The package supports many features, like providers that accept arguments. But to keep things simple, here is a basic example to get you started:

1. Create a provider top level.

    ```dart {1}
    final modelProvider = Provider((context) => Model());
    ```

    **Note:** the state is never stored globally, directly in the Provider instance; see this provider solely as a type-safe identifier.

2. Scope/provide the provider.

    ```dart {7, 8, 9, 10}
    class ProvidingWidget extends StatelessWidget {
      
      const ProvidingWidget({super.key});

      @override
      Widget build(BuildContext context) {
        return ProviderScope(
          providers: [modelProvider],
          child: MyWidget(),
        );
      }
    }
    ```

    **Note:** the actual state for the provider is created and stored inside the `ProviderScope` instance where the provider is referenced.
    This way, when the ProviderScope gets disposed, the state gets disposed — making it ideal for managing **local state**.

3. Inject the provider directly inside a new stateless widget or a stateful widget's state.

    ```dart {7}
    class InjectingWidget extends StatelessWidget {

      const InjectingWidget({super.key});

      @override
      Widget build(BuildContext context) {
        final model = modelProvider.of(context);
        // return .. (use model here)
      }
    }
    ```

    **Note:** the `ProviderScope` defined in step 2 needs to be an ancestor of this `InjectingWidget` widget.

### Widget tree structure

To make things clear, here is the widget tree structure from the example above, shown in the most detailed form:

* `modelProvider` — a globally defined provider

* `main` — the entry point of every Dart application, also global

  * ... — setup widget(s)

    * `ProvidingWidget`

      * `ProviderScope` — *`modelProvider` is provided here*

        * `MyWidget`

          * ... — widget(s)

            * `InjectingWidget` — *`modelProvider` is injected here*

              * ... — widget(s)

### What is unique about this library

The **key difference between Disco and other established solutions** is that Disco **does not rely solely on types** for providing and injecting dependencies.

For instance, the [Provider](https://pub.dev/packages/provider) package requires you to declare providers directly in the widget tree using something like `Provider(create: (_) => MyModel())`, and later retrieve them with `context.read<Model>()` or similar. This approach works well but is limited — it injects the *first instance of the given type* it finds, which can be restrictive.

Disco, by contrast, uses **globally defined provider instances as identifiers**. This allows for much greater flexibility, including defining **multiple providers of the same type**. For example:

```dart
final secondModelProvider = Provider((context) => Model());
```

This kind of setup isn't possible with Provider or most other scoped DI libraries in the ecosystem — unless you resort to defining separate wrapper types like `MyModelWrapper1` and `MyModelWrapper2`.

<details>
<summary><strong>If the difference is still not clear</strong>, click <strong>here</strong> to expand</summary>

---
---
---

#### Conceptual Syntax Comparison

The table below highlights the core conceptual difference: traditional DI solutions inject based on **type**, whereas Disco injects based on **provider instances**. If Disco followed the same method-style API, it might look like `context.read(modelProvider)` — which is more intuitive in direct comparisons.

| Typical Scoped DI (e.g., Provider) | Disco (conceptual syntax)               |
| ---------------------------------- | --------------------------------------- |
| `context.read<MyModel>()`          | `context.read(modelProvider)`           |
| Not possible to inject 2nd provider of same type          | `context.read(secondModelProvider)`           |

#### Actual Syntax Comparison

Disco intentionally flips the order — the provider comes first — to better align with Flutter conventions (`.of(context)`) and improve clarity. This makes it immediately obvious **what** you're injecting. This syntax is also slightly better for autocomplete and inlay hints display a more concise type.

| Provider                  | Disco (actual syntax)       |
| ------------------------- | --------------------------- |
| `context.read<MyModel>()` | `modelProvider.of(context)` |
| Not possible to inject 2nd provider of same type          | `secondModelProvider.of(context)`           |

---
---
---

</details>

## Trade-offs

### Pros

The pros of Disco are:

- The providers are scoped.
  - The widget tree is fully leveraged.
    - This keeps the architecture simple.
- No global state is possible.
  - Circular dependencies are impossible.
- Multiple providers of the same type are possible.
  - There is no need to create wrapper types or rely on IDs such as strings.
- The API is very simple and feels natural to Flutter.
  - Providers are equipped with `of(context)` and `maybeOf(context)` methods.
  - All you need is `BuildContext`. There is no additional class needed to inject the providers.
- The removal of a provider has an impact on its providing and each of its injections.
  - Each of them is immediately characterized by a static error.
- The values held by the providers are immutable.
  - While immutable, some instances allow for inner mutation.
    - This is great: observables and signals can be passed down.
- No reactivity is included.
  - This library focuses on DI, so that state management solutions can focus on the reactivity.
  - To include reactivity, provide a built-in or third-party observable/signal to the provider (e.g. `Signal`, `ChangeNotifier`, `Cubit`, ...).

### Cons

The cons of this library are:

- Providers might need to be lifted up or down in the widget tree, as requirements change.
- Modals spawn new widget trees, causing disconnection with the providers in the main tree.
  - A special widget must be used to restore access to the providers in the main widget tree.
- It is not fully compile-time safe.
  - The injection of a provider that cannot be found in any scope results in a runtime error.

In Disco's defense regarding the last point:

- Total compile-time safety is not possible with an approach leveraging scoped DI, which is a pattern ubiquitously used in Flutter and third-party libraries (think about how many times you have already read `MediaQuery.of(context)`, `GoRouter.of(context)`, ...).
- Disco providers also have a `maybeOf(context)` method, which can help if the presence of a provider cannot be guaranteed.
- The throwable includes precise information in its stack trace to deduce the missing provider: filepath, line and column.

### Keep in mind

As the <a href="/authors">authors of Disco</a>, we believe this to be the most effective strategy for DI in Flutter. However, every solution has trade-offs. You can limit the impact of these trade-offs by running tests, doing code reviews, and following other crucial practices.
